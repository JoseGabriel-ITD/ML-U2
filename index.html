<!DOCTYPE html>
<html lang="es" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador Interactivo de Modelos de Regresión</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals & Slate -->
    <!-- Application Structure Plan: Se ha diseñado una aplicación de página única (SPA) con una barra de navegación superior fija que permite el desplazamiento suave a secciones dedicadas para cada modelo de regresión. Esta estructura fue elegida para facilitar la comparación directa y el acceso no lineal a la información. Cada sección contiene una explicación teórica, una visualización interactiva de Chart.js que demuestra el comportamiento del modelo, y controles (como deslizadores) para que el usuario manipule los hiperparámetros clave (ej. max_depth en árboles) y observe el efecto en tiempo real. Este enfoque de "aprender haciendo" es más efectivo que una lectura pasiva, permitiendo al usuario construir una intuición sobre el sesgo, la varianza y el sobreajuste. -->
    <!-- Visualization & Content Choices: 
    - Report Info: Conceptos de 5 modelos de regresión.
    - Goal: Comparar, Explorar, Entender.
    - Viz/Presentation Method: Se utiliza un gráfico de dispersión (scatter plot) de Chart.js como base visual en todas las secciones para mantener la consistencia. Sobre este, se superpone la línea o curva de predicción de cada modelo. Los conceptos complejos (como la estructura de un árbol o el margen de SVR) se representan visualmente a través de la forma de la predicción y elementos adicionales en el gráfico.
    - Interaction: Los usuarios interactúan a través de la navegación principal y los controles específicos de cada modelo (deslizadores para 'max_depth' y 'epsilon'). La interacción principal es observar cómo la línea de predicción se ajusta a los datos al cambiar un parámetro, lo que demuestra visualmente la flexibilidad y las características de cada modelo.
    - Justification: Este enfoque interactivo transforma conceptos abstractos en resultados visuales tangibles. Por ejemplo, ver cómo una línea de árbol de decisión se vuelve más "escalonada" al aumentar la profundidad es una forma muy poderosa de enseñar el concepto de sobreajuste.
    - Library/Method: Chart.js (Canvas), HTML/CSS con Tailwind para diagramas simples.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 450px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .nav-link {
            transition: color 0.3s, border-color 0.3s;
        }
        .nav-link.active {
            color: #2563eb;
            border-color: #2563eb;
        }
    </style>
</head>
<body class="text-slate-700">

    <header class="bg-white/80 backdrop-blur-md shadow-sm sticky top-0 z-50">
        <nav class="container mx-auto px-4">
            <div class="flex items-center justify-between h-16">
                <h1 class="text-xl font-bold text-slate-800">Modelos de Regresión</h1>
                <div class="hidden md:flex items-center space-x-6">
                    <a href="#intro" class="nav-link border-b-2 border-transparent hover:text-blue-600">Introducción</a>
                    <a href="#simple-linear" class="nav-link border-b-2 border-transparent hover:text-blue-600">Lineal Simple</a>
                    <a href="#multiple-linear" class="nav-link border-b-2 border-transparent hover:text-blue-600">Lineal Múltiple</a>
                    <a href="#decision-tree" class="nav-link border-b-2 border-transparent hover:text-blue-600">Árboles</a>
                    <a href="#random-forest" class="nav-link border-b-2 border-transparent hover:text-blue-600">Random Forest</a>
                    <a href="#svm" class="nav-link border-b-2 border-transparent hover:text-blue-600">SVR</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-4 py-8 md:py-12">
        <section id="intro" class="mb-16 text-center">
            <h2 class="text-3xl md:text-4xl font-bold text-slate-900 mb-4">Aprendizaje Supervisado: Regresión</h2>
            <p class="max-w-3xl mx-auto text-lg text-slate-600">
                Esta aplicación interactiva explora los modelos de regresión, una técnica fundamental del aprendizaje supervisado. El objetivo de la regresión es predecir un valor numérico continuo (como el precio de un coche) basándose en un conjunto de variables de entrada. Aquí, visualizaremos cómo diferentes algoritmos aprenden y modelan la relación entre la potencia de un motor y el precio de un vehículo.
            </p>
        </section>

        <!-- Regresión Lineal Simple -->
        <section id="simple-linear" class="py-12 bg-white rounded-xl shadow-lg mb-12">
            <div class="px-6 md:px-10">
                <h3 class="text-2xl font-bold text-slate-900 mb-2">1. Regresión Lineal Simple</h3>
                <p class="mb-6 text-slate-600 max-w-4xl">
                    Este es el modelo más básico. Asume que existe una relación lineal entre una única variable de entrada (predictora) y la variable de salida (objetivo). El modelo busca encontrar la línea recta que mejor se ajusta a los datos, minimizando la distancia vertical entre la línea y los puntos de datos reales (error). La ecuación es de la forma <strong>Y = β₀ + β₁X + ε</strong>.
                </p>
                <div class="grid md:grid-cols-5 gap-8">
                    <div class="md:col-span-3">
                         <div class="chart-container">
                            <canvas id="simpleLinearChart"></canvas>
                        </div>
                    </div>
                    <div class="md:col-span-2 bg-slate-50 p-6 rounded-lg">
                        <h4 class="font-bold text-lg mb-3 text-slate-800">Conceptos Clave</h4>
                        <ul class="space-y-3 text-slate-600">
                            <li><strong>Objetivo:</strong> Predecir el precio (Y) basándose únicamente en la potencia (X).</li>
                            <li><strong>Visualización:</strong> El gráfico muestra los datos de los coches como puntos azules. La línea roja es la predicción del modelo: la "mejor" línea recta que resume la tendencia de los datos.</li>
                            <li><strong>Fortalezas:</strong> Simple de interpretar, computacionalmente eficiente y funciona bien cuando la relación es verdaderamente lineal.</li>
                             <li><strong>Debilidades:</strong> Demasiado simple para problemas complejos, muy sensible a valores atípicos.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Regresión Lineal Múltiple -->
        <section id="multiple-linear" class="py-12 bg-white rounded-xl shadow-lg mb-12">
            <div class="px-6 md:px-10">
                <h3 class="text-2xl font-bold text-slate-900 mb-2">2. Regresión Lineal Múltiple</h3>
                <p class="mb-6 text-slate-600 max-w-4xl">
                    Es una extensión de la regresión lineal simple. Utiliza múltiples variables de entrada para predecir la variable de salida. La idea es la misma: encontrar la mejor relación lineal, pero ahora en un espacio de más dimensiones. La ecuación se expande a <strong>Y = β₀ + β₁X₁ + β₂X₂ + ... + βₙXₙ + ε</strong>.
                </p>
                <div class="grid md:grid-cols-5 gap-8">
                    <div class="md:col-span-3">
                         <div class="chart-container">
                            <canvas id="multipleLinearChart"></canvas>
                        </div>
                    </div>
                    <div class="md:col-span-2 bg-slate-50 p-6 rounded-lg">
                        <h4 class="font-bold text-lg mb-3 text-slate-800">Conceptos Clave</h4>
                        <ul class="space-y-3 text-slate-600">
                           <li><strong>Objetivo:</strong> Predecir el precio (Y) usando la potencia y otras variables como el tamaño del motor (que no se ven en el gráfico 2D, pero influyen en el modelo).</li>
                           <li><strong>Visualización:</strong> Aunque el modelo usa múltiples variables, solo podemos visualizar la relación con una a la vez. La línea roja muestra la predicción del precio en función de la potencia, considerando el efecto de las otras variables.</li>
                           <li><strong>Fortalezas:</strong> Permite capturar relaciones más complejas y generalmente ofrece predicciones más precisas que la regresión simple.</li>
                           <li><strong>Debilidades:</strong> Asume que no hay correlación entre las variables predictoras (multicolinealidad), lo cual puede ser un problema.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Árbol de Regresión -->
        <section id="decision-tree" class="py-12 bg-white rounded-xl shadow-lg mb-12">
            <div class="px-6 md:px-10">
                <h3 class="text-2xl font-bold text-slate-900 mb-2">3. Árbol de Regresión</h3>
                <p class="mb-6 text-slate-600 max-w-4xl">
                    Este modelo no lineal divide el conjunto de datos en subconjuntos más pequeños y homogéneos. Imagina que hace una serie de preguntas del tipo "si/no" sobre las variables de entrada. Para cada región resultante, la predicción es simplemente el valor promedio de la variable objetivo. El resultado es una función a trozos o escalonada.
                </p>
                <div class="grid md:grid-cols-5 gap-8">
                    <div class="md:col-span-3">
                         <div class="chart-container">
                            <canvas id="decisionTreeChart"></canvas>
                        </div>
                        <div class="mt-4 px-4">
                            <label for="treeDepth" class="block mb-2 font-medium text-slate-700">Profundidad máxima del árbol: <span id="treeDepthValue" class="font-bold text-blue-600">2</span></label>
                            <input type="range" id="treeDepth" min="1" max="6" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div class="md:col-span-2 bg-slate-50 p-6 rounded-lg">
                        <h4 class="font-bold text-lg mb-3 text-slate-800">Conceptos Clave</h4>
                        <ul class="space-y-3 text-slate-600">
                            <li><strong>Objetivo:</strong> Segmentar el espacio de características (potencia) para hacer predicciones.</li>
                            <li><strong>Interacción:</strong> Mueve el deslizador de "Profundidad máxima". Con una profundidad baja, el modelo es simple. Al aumentarla, el árbol hace más divisiones, ajustándose más a los datos de entrenamiento. ¡Cuidado con el sobreajuste (overfitting)!</li>
                            <li><strong>Visualización:</strong> La línea roja escalonada muestra las predicciones del árbol. Cada "escalón" representa una región (hoja del árbol) con una predicción constante.</li>
                            <li><strong>Fortalezas:</strong> Fácil de interpretar y visualizar, puede capturar relaciones no lineales.</li>
                            <li><strong>Debilidades:</strong> Propenso al sobreajuste, inestable (pequeños cambios en los datos pueden cambiar el árbol drásticamente).</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Random Forest -->
        <section id="random-forest" class="py-12 bg-white rounded-xl shadow-lg mb-12">
            <div class="px-6 md:px-10">
                <h3 class="text-2xl font-bold text-slate-900 mb-2">4. Random Forest para Regresión</h3>
                <p class="mb-6 text-slate-600 max-w-4xl">
                    Es un modelo de "ensamble". En lugar de construir un solo árbol de decisión, construye muchos árboles (un "bosque") de forma aleatoria y promedia sus predicciones. Esta técnica reduce drásticamente el sobreajuste del que sufren los árboles individuales y mejora la robustez y precisión del modelo.
                </p>
                <div class="grid md:grid-cols-5 gap-8">
                    <div class="md:col-span-3">
                         <div class="chart-container">
                            <canvas id="randomForestChart"></canvas>
                        </div>
                    </div>
                    <div class="md:col-span-2 bg-slate-50 p-6 rounded-lg">
                        <h4 class="font-bold text-lg mb-3 text-slate-800">Conceptos Clave</h4>
                        <ul class="space-y-3 text-slate-600">
                           <li><strong>Objetivo:</strong> Combinar la sabiduría de muchos árboles para una predicción más estable y precisa.</li>
                           <li><strong>Visualización:</strong> La línea de predicción roja es mucho más suave y menos "nerviosa" que la de un solo árbol. Representa el promedio de las predicciones de todos los árboles del bosque, capturando la tendencia general sin memorizar el ruido de los datos.</li>
                           <li><strong>Fortalezas:</strong> Muy preciso y robusto, resistente al sobreajuste, maneja bien un gran número de características.</li>
                           <li><strong>Debilidades:</strong> Es un modelo de "caja negra", lo que significa que es mucho más difícil de interpretar que un solo árbol.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Support Vector Regression -->
        <section id="svm" class="py-12 bg-white rounded-xl shadow-lg mb-12">
            <div class="px-6 md:px-10">
                <h3 class="text-2xl font-bold text-slate-900 mb-2">5. Máquinas de Vectores de Soporte para Regresión (SVR)</h3>
                <p class="mb-6 text-slate-600 max-w-4xl">
                    El objetivo de SVR es similar al de otros modelos, pero con un enfoque diferente. En lugar de minimizar el error de todos los puntos, intenta ajustar una línea (o hiperplano) a los datos de tal manera que la mayor cantidad de puntos de datos se encuentren dentro de un "margen" o "calle" alrededor de la línea. Solo los puntos fuera de este margen influyen en la decisión.
                </p>
                <div class="grid md:grid-cols-5 gap-8">
                    <div class="md:col-span-3">
                        <div class="chart-container">
                            <canvas id="svmChart"></canvas>
                        </div>
                         <div class="mt-4 px-4">
                            <label for="epsilonSlider" class="block mb-2 font-medium text-slate-700">Margen de error (Epsilon): <span id="epsilonValue" class="font-bold text-blue-600">5000</span></label>
                            <input type="range" id="epsilonSlider" min="1000" max="10000" value="5000" step="500" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div class="md:col-span-2 bg-slate-50 p-6 rounded-lg">
                        <h4 class="font-bold text-lg mb-3 text-slate-800">Conceptos Clave</h4>
                        <ul class="space-y-3 text-slate-600">
                            <li><strong>Objetivo:</strong> Encontrar una función que se desvíe como máximo un valor <strong>ε (epsilon)</strong> de los valores reales para la mayoría de los datos.</li>
                            <li><strong>Interacción:</strong> Usa el deslizador para cambiar el valor de Epsilon. Un valor más grande crea una "calle" más ancha, lo que resulta en un modelo más simple y tolerante a errores. Un valor pequeño estrecha la calle, haciendo que el modelo sea más sensible.</li>
                            <li><strong>Visualización:</strong> La línea roja es la predicción. Las líneas discontinuas definen el margen de Epsilon. El modelo no penaliza los errores de los puntos que caen dentro de este margen.</li>
                            <li><strong>Fortalezas:</strong> Efectivo en espacios de alta dimensión y cuando el número de dimensiones es mayor que el número de muestras.</li>
                            <li><strong>Debilidades:</strong> No funciona bien con conjuntos de datos muy grandes y es sensible a la elección de hiperparámetros.</li>
                        </ul>
                    </div>
                </div>
            </section>
            
        <section id="references" class="pt-12 mt-12 border-t">
            <h3 class="text-2xl font-bold text-slate-900 mb-4 text-center">Referencias y Lecturas Adicionales</h3>
            <ul class="list-disc list-inside max-w-3xl mx-auto space-y-2 text-slate-600">
                <li>James, G., Witten, D., Hastie, T., & Tibshirani, R. (2013). <em>An Introduction to Statistical Learning</em>. Springer.</li>
                <li>Scikit-learn User Guide. (n.d.). <a href="https://scikit-learn.org/stable/supervised_learning.html" target="_blank" class="text-blue-600 hover:underline">Supervised learning</a>.</li>
                <li>IBM. (n.d.). <a href="https://www.ibm.com/topics/supervised-learning" target="_blank" class="text-blue-600 hover:underline">What is Supervised Learning?</a></li>
                <li>Google for Developers. (n.d.). <a href="https://developers.google.com/machine-learning/crash-course/descending-into-ml/linear-regression" target="_blank" class="text-blue-600 hover:underline">Linear Regression</a>.</li>
            </ul>
        </section>

    </main>
    <footer class="text-center py-6 mt-8 bg-white border-t">
        <p class="text-slate-500">Aplicación interactiva creada para la exploración de conceptos de Machine Learning.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            
            const carData = [
                { horsepower: 111, price: 13495 }, { horsepower: 111, price: 16500 },
                { horsepower: 154, price: 16500 }, { horsepower: 102, price: 13950 },
                { horsepower: 115, price: 17450 }, { horsepower: 110, price: 15250 },
                { horsepower: 110, price: 17710 }, { horsepower: 110, price: 18920 },
                { horsepower: 140, price: 23875 }, { horsepower: 160, price: 17859.167 },
                { horsepower: 101, price: 16430 }, { horsepower: 101, price: 16925 },
                { horsepower: 121, price: 20970 }, { horsepower: 121, price: 21105 },
                { horsepower: 121, price: 24565 }, { horsepower: 182, price: 30760 },
                { horsepower: 182, price: 41315 }, { horsepower: 182, price: 36880 },
                { horsepower: 70, price: 5151 },   { horsepower: 68, price: 6295 },
                { horsepower: 68, price: 6575 },   { horsepower: 62, price: 5385 },
                { horsepower: 76, price: 6189 },   { horsepower: 76, price: 6692 },
                { horsepower: 76, price: 7609 },   { horsepower: 120, price: 12940 },
                { horsepower: 120, price: 13415 }, { horsepower: 176, price: 16503 },
                { horsepower: 262, price: 32250 }, { horsepower: 262, price: 35550 },
                { horsepower: 262, price: 36000 }, { horsepower: 145, price: 15510 },
                { horsepower: 145, price: 18150 }, { horsepower: 207, price: 40960 },
                { horsepower: 207, price: 45400 }, { horsepower: 175, price: 34184 },
                { horsepower: 200, price: 38500 }, { horsepower: 200, price: 42000 },
                { horsepower: 88, price: 7775 }, { horsepower: 88, price: 7975 },
                { horsepower: 152, price: 12945 }, { horsepower: 152, price: 13450 },
                { horsepower: 116, price: 8916.5 },{ horsepower: 116, price: 10698 }
            ].sort((a, b) => a.horsepower - b.horsepower);

            const scatterData = carData.map(d => ({ x: d.horsepower, y: d.price }));
            const labels = carData.map(d => d.horsepower);
            
            const defaultChartOptions = {
                maintainAspectRatio: false,
                responsive: true,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'Potencia (HP)',
                            font: { size: 14 }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Precio ($)',
                            font: { size: 14 }
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Potencia: ${context.parsed.x} HP, Precio: $${context.parsed.y.toFixed(2)}`;
                            }
                        }
                    }
                }
            };

            const scatterDataset = {
                label: 'Datos de coches',
                data: scatterData,
                backgroundColor: 'rgba(59, 130, 246, 0.5)',
                borderColor: 'rgba(59, 130, 246, 1)',
                pointRadius: 5,
                pointHoverRadius: 7,
                type: 'scatter'
            };

            function getLineDataset(label, data, color) {
                return {
                    label: label,
                    data: data,
                    borderColor: color,
                    backgroundColor: color,
                    borderWidth: 3,
                    type: 'line',
                    pointRadius: 0,
                    fill: false,
                    tension: 0.1
                };
            }
            
            const minHp = Math.min(...labels);
            const maxHp = Math.max(...labels);

            // 1. Simple Linear Regression
            const simpleLinearPrediction = (hp) => 250 * hp - 12000;
            const simpleLinearData = [{x: minHp, y: simpleLinearPrediction(minHp)}, {x: maxHp, y: simpleLinearPrediction(maxHp)}];
            new Chart(document.getElementById('simpleLinearChart'), {
                type: 'scatter',
                data: {
                    datasets: [scatterDataset, getLineDataset('Predicción Lineal Simple', simpleLinearData, 'rgba(239, 68, 68, 0.8)')]
                },
                options: defaultChartOptions
            });
            
            // 2. Multiple Linear Regression
            const multipleLinearPrediction = (hp) => 265 * hp - 15000;
            const multipleLinearData = [{x: minHp, y: multipleLinearPrediction(minHp)}, {x: maxHp, y: multipleLinearPrediction(maxHp)}];
            new Chart(document.getElementById('multipleLinearChart'), {
                type: 'scatter',
                data: {
                    datasets: [scatterDataset, getLineDataset('Predicción Lineal Múltiple', multipleLinearData, 'rgba(239, 68, 68, 0.8)')]
                },
                options: defaultChartOptions
            });

            // 3. Decision Tree
            const treeDepthSlider = document.getElementById('treeDepth');
            const treeDepthValue = document.getElementById('treeDepthValue');
            const treePredictions = {
                1: [{x:60,y:8000},{x:130,y:8000},{x:130,y:25000},{x:270,y:25000}],
                2: [{x:60,y:6500},{x:100,y:6500},{x:100,y:15000},{x:180,y:15000},{x:180,y:38000},{x:270,y:38000}],
                3: [{x:60,y:6000},{x:80,y:6000},{x:80,y:10000},{x:110,y:10000},{x:110,y:17000},{x:150,y:17000},{x:150,y:32000},{x:200,y:32000},{x:200,y:40000},{x:270,y:40000}],
                6: [{x:60,y:5200},{x:65,y:5200},{x:65,y:6400},{x:72,y:6400},{x:72,y:7600},{x:80,y:7600},{x:80,y:8800},{x:95,y:8800},{x:95,y:14000},{x:110,y:14000},{x:110,y:16500},{x:120,y:16500},{x:120,y:21000},{x:150,y:21000},{x:150,y:24000},{x:160,y:24000},{x:160,y:30000},{x:180,y:30000},{x:180,y:36000},{x:200,y:36000},{x:200,y:41000},{x:250,y:41000},{x:250,y:45000},{x:270,y:45000}]
            };

            const decisionTreeChart = new Chart(document.getElementById('decisionTreeChart'), {
                type: 'scatter',
                data: {
                    datasets: [scatterDataset, {...getLineDataset('Predicción de Árbol', treePredictions[2], 'rgba(239, 68, 68, 0.8)'), stepped: true}]
                },
                options: defaultChartOptions
            });

            treeDepthSlider.addEventListener('input', (e) => {
                const depth = e.target.value;
                treeDepthValue.textContent = depth;
                const predictionData = treePredictions[depth] || treePredictions[6];
                decisionTreeChart.data.datasets[1].data = predictionData;
                decisionTreeChart.update();
            });

            // 4. Random Forest
            const rfData = [
              {x: 62, y: 6000}, {x: 75, y: 7200}, {x: 88, y: 9000}, {x: 101, y: 14000},
              {x: 111, y: 15500}, {x: 121, y: 18000}, {x: 140, y: 22000}, {x: 154, y: 25000},
              {x: 176, y: 30000}, {x: 182, y: 35000}, {x: 207, y: 39000}, {x: 262, y: 41000}
            ];
            new Chart(document.getElementById('randomForestChart'), {
                type: 'scatter',
                data: {
                    datasets: [scatterDataset, getLineDataset('Predicción Random Forest', rfData, 'rgba(239, 68, 68, 0.8)')]
                },
                options: defaultChartOptions
            });

            // 5. SVR
            const epsilonSlider = document.getElementById('epsilonSlider');
            const epsilonValue = document.getElementById('epsilonValue');
            const svmPrediction = (hp) => 210 * hp - 9000;

            const svmChart = new Chart(document.getElementById('svmChart'), {
                type: 'scatter',
                data: {
                    datasets: [
                        scatterDataset, 
                        getLineDataset('Predicción SVR', [], 'rgba(239, 68, 68, 0.8)'),
                        {...getLineDataset('Margen Superior', [], 'rgba(239, 68, 68, 0.4)'), borderDash: [5, 5], borderWidth: 2},
                        {...getLineDataset('Margen Inferior', [], 'rgba(239, 68, 68, 0.4)'), borderDash: [5, 5], borderWidth: 2}
                    ]
                },
                options: defaultChartOptions
            });
            
            function updateSvmChart(epsilon) {
                epsilonValue.textContent = epsilon;
                const svmData = [{x: minHp, y: svmPrediction(minHp)}, {x: maxHp, y: svmPrediction(maxHp)}];
                const svmUpper = svmData.map(p => ({ x: p.x, y: p.y + epsilon }));
                const svmLower = svmData.map(p => ({ x: p.x, y: p.y - epsilon }));

                svmChart.data.datasets[1].data = svmData;
                svmChart.data.datasets[2].data = svmUpper;
                svmChart.data.datasets[3].data = svmLower;
                svmChart.update();
            }

            epsilonSlider.addEventListener('input', (e) => {
                updateSvmChart(parseInt(e.target.value));
            });
            
            updateSvmChart(parseInt(epsilonSlider.value));
            
            // Active Nav Link on Scroll
            const sections = document.querySelectorAll('section[id]');
            const navLinks = document.querySelectorAll('.nav-link');

            window.addEventListener('scroll', () => {
                let current = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (pageYOffset >= sectionTop - 80) {
                        current = section.getAttribute('id');
                    }
                });
                
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href').includes(current)) {
                        link.classList.add('active');
                    }
                });
            });
        });

    </script>
</body>
</html>
